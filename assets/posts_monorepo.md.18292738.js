import{_ as s,c as n,o as p,b as a}from"./app.d0d9d5f2.js";const l="/vitepress-blog/assets/WX20230725-212348@2x.1ff63d24.png",o="/vitepress-blog/assets/WX20230725-212849@2x.7863f9a0.png",e="/vitepress-blog/assets/WX20230725-213138@2x.6159fb2b.png",t="/vitepress-blog/assets/WX20230725-220746@2x.ffd84d3a.png",h=JSON.parse('{"title":"monorepo架构改造公司SDK","description":"monorepo pnpm","frontmatter":{"title":"monorepo架构改造公司SDK","description":"monorepo pnpm","aside":false,"date":"2023-5-31","tags":["monorepo"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"什么是 monorepo","slug":"什么是-monorepo","link":"#什么是-monorepo","children":[]},{"level":2,"title":"pnpm","slug":"pnpm","link":"#pnpm","children":[]},{"level":2,"title":"pnpm workspace 实践","slug":"pnpm-workspace-实践","link":"#pnpm-workspace-实践","children":[{"level":3,"title":"1. 新建仓库并初始化","slug":"_1-新建仓库并初始化","link":"#_1-新建仓库并初始化","children":[]},{"level":3,"title":"2. 指定项目运行的 Node、pnpm 版本","slug":"_2-指定项目运行的-node、pnpm-版本","link":"#_2-指定项目运行的-node、pnpm-版本","children":[]},{"level":3,"title":"3. 安全性设置","slug":"_3-安全性设置","link":"#_3-安全性设置","children":[]},{"level":3,"title":"4. 安装包","slug":"_4-安装包","link":"#_4-安装包","children":[]}]},{"level":2,"title":"pnpm 和 npm 的区别","slug":"pnpm-和-npm-的区别","link":"#pnpm-和-npm-的区别","children":[]}],"relativePath":"posts/monorepo.md"}'),c={name:"posts/monorepo.md"},r=a(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>公司想要把 SDK 暴露出去，给合作公司调用，另外，我们需要把模型操作相关代码以插件的形式供团队调用，最近 monorepo 架构比较流行，借助 pnpm，我们可以将其改造一下。</p><h2 id="什么是-monorepo" tabindex="-1">什么是 monorepo <a class="header-anchor" href="#什么是-monorepo" aria-hidden="true">#</a></h2><p>简单来说就是，将多个项目或包文件放到一个 git 仓库来管理。 目前比较广泛应用的是 yarn+lerna 的方式实现 monorepo 的管理。 一个简单的 monorepo 的目录结构类似这样：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">├── README</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">md</span></span>
<span class="line"><span style="color:#A6ACCD;">├── lerna</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">├── </span><span style="color:#89DDFF;font-style:italic;">package</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">lock</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">├── package</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">├── packages</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── </span><span style="color:#89DDFF;">@</span><span style="color:#A6ACCD;">soonspacejs</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── plugin</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">camera</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">follower</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── plugin</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">clipping</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">controls</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── plugin</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">drawing</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">shape</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── plugin</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">drawing</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">topology</span></span>
<span class="line"><span style="color:#A6ACCD;">│   │   ├── plugin</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">effect</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── soonspacejs</span></span>
<span class="line"><span style="color:#A6ACCD;">│       ├── README</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">md</span></span>
<span class="line"><span style="color:#A6ACCD;">│       ├── package</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">│       └── src</span></span>
<span class="line"><span style="color:#A6ACCD;">├── rollup</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">config</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">└── tsconfig</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"></span></code></pre></div><blockquote><p>如上图，我们把 threejs 相关代码放到 soonspacejs 文件里，一些绘制、操作模型的代码以插件形式放到@soonspacejs 文件里。</p></blockquote><p>之所以应用 monorepo，主要是解决以下问题：</p><ul><li><p>代码复用的问题</p></li><li><p>开发流程统一</p></li><li><p>高效管理多项目/包</p></li></ul><h2 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-hidden="true">#</a></h2><p>pnpm 相对于 yarn/npm 的优势</p><ul><li><p>安装速度最快（非扁平的包结构，没有 yarn/npm 的复杂的扁平算法，且只更新变化的文件）</p></li><li><p>节省磁盘空间 （统一安装包到磁盘的某个位置，项目中的 node_modules 通过硬连接的方式链接到实际的安装地址）</p></li></ul><h2 id="pnpm-workspace-实践" tabindex="-1">pnpm workspace 实践 <a class="header-anchor" href="#pnpm-workspace-实践" aria-hidden="true">#</a></h2><h3 id="_1-新建仓库并初始化" tabindex="-1">1. 新建仓库并初始化 <a class="header-anchor" href="#_1-新建仓库并初始化" aria-hidden="true">#</a></h3><p>新建目录 pnpm-workspace-demo，执行 npm init / pnpm init 初始化项目，生成 package.json</p><h3 id="_2-指定项目运行的-node、pnpm-版本" tabindex="-1">2. 指定项目运行的 Node、pnpm 版本 <a class="header-anchor" href="#_2-指定项目运行的-node、pnpm-版本" aria-hidden="true">#</a></h3><p>为了减少因 node 或 pnpm 的版本的差异而产生开发环境错误，我们在 package.json 中增加 engines 字段来限制版本。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">engines</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">node</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">&gt;=16</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">pnpm</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">&gt;=7</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="_3-安全性设置" tabindex="-1">3. 安全性设置 <a class="header-anchor" href="#_3-安全性设置" aria-hidden="true">#</a></h3><p>为了防止我们的根目录被当作包发布，我们需要在 package.json 加入如下设置：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">private</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>pnpm 本身就支持 monorepo，不用另外安装第三方包。每个 monorepo 的根目录下必须包含 pnpm-workspace.yaml 文件</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F07178;">packages</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;"># all packages in direct subdirs of packages/</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">packages/*</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><h3 id="_4-安装包" tabindex="-1">4. 安装包 <a class="header-anchor" href="#_4-安装包" aria-hidden="true">#</a></h3><p><strong>全局依赖包</strong></p><p>有些依赖包需要安装到根目录，比如 threejs、rollup、chalk、inquirer、typescript 等，运行一下命令：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">pnpm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">rollup</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">chalk</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">inquirer</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">typescript</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-Dw</span></span>
<span class="line"></span></code></pre></div><p>-w 表示在 workspace 的根目录下安装而不是当前的目录</p><p>与安装命令 pnpm add pkgname 相反的的删除依赖包 pnpm rm/remove pkgname 或 pnpm un/uninstall pkgname</p><p><strong>子包依赖</strong></p><p>有两种方法，一个是进入子包目录直接安装 pnpm add pkgname，另一个通过-f 指定范围：</p><p><code>pnpm --filter/-F 具体包目录名/包的name/正则匹配包名/匹配目录 command</code></p><p>如：pnpm -f @soonspace/plugin-camera-follower add soonspacejs</p><h2 id="pnpm-和-npm-的区别" tabindex="-1">pnpm 和 npm 的区别 <a class="header-anchor" href="#pnpm-和-npm-的区别" aria-hidden="true">#</a></h2><p>目前，使用 npm/yarn 安装包是扁平结构（以前是嵌套结构，npm3 之后改为扁平结构）</p><p>扁平结构 就是安装一个包，那么这个包依赖的包将一起被安装到与这个包同级的目录下。比如安装一个 koa 包，打开目录下的 node_modules 会发现除了 koa 之外，多出很多其他的包。如图：</p><p><img src="`+l+`" alt=""></p><p>嵌套结构 就是一个包的依赖包会安装在这个包文件下的 node_modules 下，而依赖的依赖会安装到依赖包文件的 node_modules 下。依此类推。如下所示:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ foo</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├─ node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">     ├─ bar</span></span>
<span class="line"><span style="color:#A6ACCD;">       ├─ index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">       └─ package</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├─ index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">  └─ package</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"></span></code></pre></div><p>嵌套结构的问题在于：</p><ul><li><p>包文件的目录可能会非常长</p></li><li><p>重复安装包</p></li><li><p>相同包的实例不能共享</p></li></ul><p>而扁平结构也同样存在问题：</p><ul><li><p>依赖结构的不确定性（不同包依赖某个包的不同版本 最终安装的版本具有不确定性）可通过 lock 文件确定安装版本</p></li><li><p>扁平化算法复杂，耗时</p></li><li><p>非法访问未声明的包</p></li></ul><p>现在，我们使用 pnpm 来安装 koa，然后打开 node_modules：</p><p><img src="`+o+'" alt=""></p><p>从上图可以发现：</p><ul><li><p>node_modules 下只有 koa 一个包，且这个被软链到了其他的地方。</p></li><li><p>.modlues.yaml 包含了一些 pnpm 包管理的配置信息。如下图:</p></li></ul><p><img src="'+e+'" alt=""></p><p>可以看到 .pnpm 目录的实际指向的 pnpm store 的路径、pnpm 包的版本等信息</p><p><img src="'+t+'" alt=""></p><p>由上图我们可以了解到：</p><ul><li><p>当我们安装 bar 包时，根目录下只包含安装的包 bar</p></li><li><p>而 node_modules 目录下的 bar 包会软链接到.pnpm/bar/node_modules/bar@*</p></li><li><p>bar 的依赖包 foo 会被提升到.pnpm 的根目录下，其他包依赖 foo 时也会软链接到这里</p></li><li><p>而 bar 和 foo 实际通过硬链接到.pnpm store 中</p></li></ul><blockquote><p>软链接可以理解成快捷方式。 它和 windows 下的快捷方式的作用是一样的。 硬链接等于 cp -p 加 同步更新。即文件大小和创建时间与源文件相同，源文件修改，硬链接的文件会同步更新。应用：可以防止别人误删你的源文件</p></blockquote><p>软链接解决了磁盘空间占用的问题，而硬链接解决了包的同步更新和统一管理问题。 还有一个巧妙的设计就是：将安装包和依赖包放在同一级目录下，即.pnpm/依赖包/node_modules 下。这个设计也就防止了 <strong>依赖包间的非法访问</strong>，根据 Node 模块路径解析规则可知，不在安装包同级的依赖包无法被访问，即只能访问安装包依赖的包。</p><p>如果你还有使用 npm/yarn 的场景，那么，可以推荐使用 <strong>ni</strong> 这个工具，它可以帮你自动识别项目使用的包管理工具，你只需要一行命名就搞定了。</p><p>比如： 执行命令 ni 安装依赖包，如果当前项目包含 pnpm-lock.yaml，那么会使用 pnpm install 执行安装命令，否则判断是否包含 package-lock.json/yarn.lock/bun.lockb，来确定使用哪个包管理工具去执行安装命令。</p>',55),i=[r];function D(y,d,C,m,A,F){return p(),n("div",null,i)}const g=s(c,[["render",D]]);export{h as __pageData,g as default};
